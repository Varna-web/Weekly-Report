

# JavaScript
## （一）基础语法

### 一、相关概念
1. **定义**：JavaScript 是一种运行在客户端（浏览器）的编程语言，作用包括网页监听与特效、表单验证、数据交互、服务端编程（node.js）。
2. **组成**：ECAMScript（基础语法） + Web APIs（DOM + BOM）。
3. **权威网站**：引擎直接搜索 MDN。
4. **书写位置**：
   - 行内：在别的标签内直接写，vue 中常用。
   - 内部：写在紧挨着 `</body>` 的上方，实际可写在任意位置。
   - 外部：以 `.js` 结尾的文件，用 `script` 标签内 `src` 属性引入；仍为双标签，放在 `body` 正上方；两个标签间不能写代码。
5. **注释**：
   - 单行注释：`//`，快捷键 `ctrl + /`。
   - 块注释：`/* */`，快捷键 `shift + alt + A`。
6. **结束符**：英文分号 `;`，按团队要求统一写或不写。

---

### 二、输入输出
1. **输入语法**：`prompt('请输入')`，显示一个对话框，上方是提示语，下方可输入内容。
2. **输出语法**：
   - `document.write('向body内输出内容，如果是标签会被解析成网页元素')`。
   - `alert('对话框')`，弹出提示对话框。
   - `console.log('控制台')`，直接输 `log` 即可；输出多个内容时用逗号分隔。
3. **执行顺序**：按照 html 文档流执行 JS 代码，`alert` 和 `prompt` 会跳过渲染先被执行。

---

### 三、变量
1. **字面量**：计算机内用于描述事物的量。
2. **变量**：存储数据的容器，起名需遵循小驼峰命名法。
   - 声明：`let 变量名`，不可多次声明同一变量，建议一行只声明一个变量。
   - 赋值：`变量名 = 字面量`；弱类型意味着一个变量名可存储不同类型的数据（包括数组）。
   - 初始化：声明的同时直接完成赋值。
3. **var**：现在已不推荐使用。
4. **数组**：将一组数据存储在单个变量名下。
   - 声明：`let 数组名 = [ ]`，可存储任何类型的数据。
   - 属性：`length`（获取数组长度）。
5. **常量**：使用 `const` 而非 `let` 声明的变量；声明时必须赋初值，且不能重新赋值。
6. **数据类型**：
   - **基本数据类型**：
     - `number`：数字类型。
     - `string`：字符串类型。
     - `boolean`：布尔类型（true/false）。
     - `undefined`：只声明不赋值时直接输出的结果，可用于检测有无数据传入。
     - `null`：已赋值但内容为空，视作尚未创建的对象。
   - **引用数据类型**：`object`（对象类型）。
   - **特殊值**：`NaN` 代表计算错误，是不正确或未定义的数学操作结果；任何对 `NaN` 的操作都会返回 `NaN`。
7. **string 细节**：
   - 单引号（`''`）、双引号（`""`）或反引号（`` ` ``）包裹的数据均为字符串，推荐用双引号。
   - 单双引号必须成对使用，二者可互相嵌套，但不能自身嵌套；可使用转义符 `\` 输出自身。
   - 输出含字符串时，`+` 表示拼接。
   - 模板字符串：字符串用反引号引起，内部的变量用 `${}` 包裹即可正常输出。
8. **控制台输出颜色**：数字和布尔值为蓝色，字符串和 `undefined` 为灰色。
9. **类型检测**：`typeof` 可作为运算符直接跟变量，或作为函数加括号使用，均返回变量的类型；一般直接写 `typeof 变量名`。

---

### 四、类型转换
1. **注意点**：使用表单、`prompt` 获取过来的数据默认是字符串类型。
2. **隐式转换**：
   - 有字符串的加法：`"" + 1`，结果是 `"1"`（二元运算符）。
   - `+` 号作为正号时是一元运算符，会将字符串转换为数字；若需将纯数字组成的字符串转为数字，直接写 `+字符串` 即可。
   - 减法 `-` 及除 `+` 之外的其他算术运算符，仅能用于数字；会使空字符串 `""` 转换为 0，纯数字字符串自动转换为数字。
   - `null` 经数字转换后变为 0，`undefined` 经数字转换后变为 `NaN`；`NaN` 的所有操作结果均为 `NaN`。
3. **显式转换**：
   - **转为数字**：
     - `Number(数据)`：转成数字；若字符串内容开头是非数字，转换失败，结果为 `NaN`（`NaN` 也是 `number` 类型，代表非数字）；若开头是数字，转换至非数字处结束。
     - `parseInt(数据)`：只保留整数部分。
     - `parseFloat(数据)`：可保留小数部分。
   - **转为字符**：
     - `String(数据)`：直接转换为字符串。
     - `变量.toString(进制)`：先转为指定进制，再转为字符串。
   - **转为布尔**：`''`、`0`、`undefined`、`null`、`false`、`NaN` 转换为布尔值后均为 `false`，其余情况均为 `true`。

## （二）语句

### 一、运算符
1. **自增自减**：`i++` 后置自增使用较多，且多单独使用，效果与前置自增无区别。
2. **全等与不全等**：
   - `===`：表示左右两边类型和值都相等，推荐使用此符号判断是否相等。
   - `!==`：表示左右两边是否不全等（类型或值不同）。
3. **比较规则**：
   - 字符串比较：从左向右依次比较字符的 ASCII 码。
   - `NaN` 特性：`NaN` 不等于任何值，包括它本身。
   - 小数比较：尽量不要比较小数，存在精度问题。
   - 不同类型比较：会发生隐式转换，最终将数据转为 `number` 类型后比较。
4. **优先级**：一元运算符里的逻辑非（`!`）优先级很高；逻辑与（`&&`）比逻辑或（`||`）优先级高。

---

### 二、语句基础
1. **表达式**：可被求值的代码，可写在赋值语句的右侧。
2. **语句**：一段可执行的代码，不一定有值。
3. **关系**：表达式也可理解为表达式语句，因其会计算结果，但不是程序必须的成分。

---

### 三、分支语句
常见分支方式包括 `if` 语句、三元表达式、`switch` 语句。
- `switch` 语句：判断时必须全等于（`===`）目标值，一般搭配 `break` 使用以避免穿透。

---

### 四、循环语句
1. **断点调试**：在开发者工具的 `sources` 栏选择代码文件，在某句代码上添加的标记即为断点；程序执行到该句时会暂停，方便调试。

---

### 五、数组操作
1. **数组声明**：定义空数组可写 `let 数组名 = []`，直接输出数组名即可查看数组内容。
2. **核心属性**：`length`（获取数组长度）。
3. **常用方法**：
   - **增**：
     - `arr.unshift(新增的内容)`：向数组开头添加内容，返回数组新长度。
     - `arr.push(新增的内容)`：向数组结尾添加内容，返回数组新长度；同时加多个内容时用逗号分隔。
   - **删**：
     - `arr.shift()`：删除数组开头第一个元素，返回被删除的元素。
     - `arr.pop()`：删除数组结尾最后一个元素，返回被删除的元素。
     - `arr.splice(起始下标, 删除的个数)`：从指定下标开始删除；省略删除个数时，默认删到数组最后。
   - **排序**：
     - `arr.sort()`：默认按升序排序。
     - 降序排序：`arr.sort(function (a, b) { return b - a })`。

---

### 六、函数
1. **函数声明**：
   - 命名规则：小驼峰命名法，常用动词（如 `can` 判断是否可执行、`has` 判断是否包含、`is` 判断是否为、`get` 获取、`set` 设置、`load` 加载）。
   - 声明方式：用 `function` 关键字声明，提倡先声明再调用。
2. **参数规则**：
   - 未输入的参数默认值为 `undefined`。
   - 形参可直接用等号赋予默认值（如 `function fn(a = 10) {}`）。
3. **返回值（return）**：
   - `return` 后立即结束当前函数，后面的数据不要换行写。
   - `return` 后不接数据，或函数内不写 `return`，返回值均为 `undefined`。
   - 需返回多个值时，可用数组包裹（如 `return [a, b]`）。
4. **函数覆盖与参数数量**：
   - 两个同名函数，后面的会覆盖前面的。
   - 形参数量多于实参时，多余形参自动填 `undefined`；实参数量多于形参时，多余实参会被忽略。
5. **变量作用域**：
   - 函数内部变量不声明直接赋值，约等于全局变量，不推荐此写法。
   - 形参为函数的局部变量。
   - 同名变量访问原则：能访问到的情况下，从当前作用域开始，向上逐层查找，遵循“就近原则”（先局部再全局）。
6. **匿名函数**：没有名字的函数，无法直接使用，需通过以下方式调用：
   - **函数表达式**：将匿名函数赋值给一个变量，通过变量名调用；必须先声明再使用（与普通函数“声明提升”不同）。
     - 示例：`let fn = function() { 函数体 }`，调用时写 `fn()`。
   - **立即执行函数**：避免全局变量之间的污染；多个立即执行函数之间用分号分隔，单个可省略分号。
     - 语法：`(function () { 函数体 })()`。
7. **逻辑运算符短路**：与 C++ 逻辑短路规则一致；可通过 `x = x || 0` 的方式设置参数默认值。

---

### 七、对象
1. **对象特性**：无序的数据集合（与数组的“有序”形成对比）。
2. **对象声明**：用花括号 `{}` 声明，包含属性和方法。
   - **属性**：属性名与值成对出现，用 `:` 分隔；多个属性之间用 `,` 分隔。
     - 属性名一般可省略单双引号，但含空格、中横线等特殊字符时必须加引号；此时访问该属性不能用普通点语法。
     - 注意：属性尽量不要叫 `name`，后续开发中有特殊用途。
   - **方法**：由方法名和函数构成，分隔和引号规则同属性（如 `method: function() { 函数体 }`）。
3. **对象操作**：
   - **新增属性**：直接赋值即可，语法 `对象名.新属性 = 新值`。
   - **删除属性**：`delete 对象名.属性名`（了解即可，实际开发中少用）。
   - **属性访问**：
     - 普通属性：`对象名.属性名`（推荐使用）。
     - 特殊属性（含特殊字符或多单词）：`对象['属性名']`（单双引号均可）。
     - 变量解析：`[]` 里的值不加引号时，会当作变量解析；需解析变量时用 `[]`，否则优先用点语法。
4. **对象遍历**：使用 `for...in` 循环，语法如下：
   ```javascript
   for (let k in obj) {
     console.log(k); // k 是对象的属性名
     console.log(obj[k]); // obj[k] 是对应属性值
   }
   ```
   注意：`k` 是变量，必须用 `[]` 语法解析，不能用点语法。
5. **内置对象 Math**：JavaScript 内部提供的对象，含多种数学运算相关的属性和方法。
   - **常用方法**：
     - `Math.random()`：生成 0-1 之间的随机数（包含 0，不包括 1）。
     - `Math.ceil(数字)`：向上取整；`Math.floor(数字)`：向下取整。
     - `Math.max(数字1, 数字2,...)`：找最大值；`Math.min(数字1, 数字2,...)`：找最小值。
     - `Math.pow(基数, 指数)`：幂运算；`Math.abs(数字)`：求绝对值。
   - **在线文档**：[https://www.w3school.com.cn/js/jsref_obj_math.asp](https://www.w3school.com.cn/js/jsref_obj_math.asp)
   - **随机数扩展**：
     - 生成 0-10 内的随机整数：`Math.floor(Math.random() * (10 + 1))`。
     - 生成 N-M 之间的随机整数：`Math.floor(Math.random() * (M - N + 1)) + N`。
     - 得到数组的随机索引号：`Math.floor(Math.random() * arr.length)`。

---

### 八、术语
| 术语           | 解释                                   | 举例                         |
| -------------- | -------------------------------------- | ---------------------------- |
| 关键字         | 在 JavaScript 中有特殊意义的词汇       | let、var、function、if、else |
| 保留字         | 目前无意义，但未来可能有特殊意义的词汇 | int、short、long、char       |
| 标识（标识符） | 变量名、函数名的另一种叫法             | -                            |
| 表达式         | 能产生值的代码，一般配合运算符出现     | 10 + 3、age >= 18            |
| 语句           | 一段可执行的代码                       | if ()、for()                 |

---

### 九、内存存储
- **简单数据类型（值类型）**：变量的数据直接在栈空间内存放。
- **引用数据类型**：用 `new` 关键字创建的对象（如 `Object`、`Array`、`Date`），数据存放在堆空间；栈空间（变量本身）存放的是其在堆空间内的地址（引用）。

## （三）Ajax

### 一、原生 AJAX
1. **AJAX 基础概念**：
   - 全称：Asynchronous JavaScript And XML（异步的 JS 和 XML）。
   - 核心能力：在浏览器中向服务器发送异步请求，最大优势是无刷新获取数据。
   - 本质：不是新编程语言，而是将现有标准组合使用的新方式。

2. **XML 简介**：
   - 定义：可扩展标记语言，用于传输和存储数据；HTML 用于呈现数据，目前 XML 已被 JSON 取代（JSON 更简洁、易解析）。
   - 与 HTML 的区别：HTML 含预定义标签（如 `<div>`），用于展示页面结构；XML 无预定义标签，所有标签可自定义，仅用于描述数据。
   - 数据格式对比（学生数据：name="孙悟空"；age=18；gender="男"）：
     - XML：`<student><name>孙悟空</name><age>18</age></student>`。
     - JSON：`{"name":"孙悟空","age":18}`。

3. **AJAX 的特点**：
   - **优点**：
     1. 不刷新页面也可与服务器端通信。
     2. 可根据用户事件（如点击、输入）更新部分页面内容。
   - **缺点**：
     1. 没有浏览历史与回退功能。
     2. 存在跨域问题。
     3. SEO（搜索引擎优化）不友好（数据动态加载，搜索引擎难以抓取）。

4. **HTTP 协议**：
   - 定义：HyperText Transfer Protocol（超文本传输协议），规定浏览器和万维网服务器之间互相通信的规则。
   - **请求报文**（浏览器向服务端申请数据）：
     - 行：请求类型（多用 GET/POST） / URL 路径 / 协议版本（一般用 1.1）。
     - 头：格式为“名字: 值”（如 `Content-Type: application/x-www-form-urlencoded`）。
     - 空行：分隔头与体的固定格式。
     - 体：GET 请求的请求体为空；POST 请求的请求体为参数（如 `name=zhangsan&age=20`）。


      - **响应报文**（服务端返回结果）：
        - 行：协议版本 / 响应状态码（200 表示成功，404 无法找到，403 被禁止，401 未授权等） / 响应状态字符串（如 200 对应 OK）。
        - 头：格式与请求头一致（“名字: 值”）。
        - 空行：分隔头与体的固定格式。
        - 体：主要返回结果，通常是 HTML 内容或数据（如 JSON）。
      - **查看报文方式**：按 F12 打开开发者工具 → 切换至「网络」栏 → 刷新页面，即可查看所有请求的行、头信息；GET 请求的参数在「Query String 参数」中，POST 请求的参数在「Form Data」中，响应体在「Response」中。

5. **Express 框架**：
   - 在 CMD 中执行 `node express文件.js` 即可启动服务，访问 `http://127.0.0.1:8000` 可查看响应。
   - 作用：相当于一个简易服务器，可与前端 AJAX 进行数据交互。

6. **AJAX 的使用**：
   - **核心对象**：`XMLHttpRequest`，AJAX 的所有操作均通过该对象实现。
   - **使用步骤**：
     1. **创建 XMLHttpRequest 对象**  
        ```javascript
        var xhr = new XMLHttpRequest();
        ```
     2. **设置请求信息**  
        - 基础配置：`xhr.open(method, url)`，`method` 为请求方式（如 GET/POST），`url` 为请求地址。  
        - 可选配置（POST 请求必设）：`xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')`，用于指定请求体格式。
     3. **发送请求**  
        - GET 请求：`xhr.send()`（无需传参）。  
        - POST 请求：`xhr.send(body)`，`body` 为请求参数（如 `name=zhangsan&age=20`）。
     4. **接收响应**  
        通过 `onreadystatechange` 事件监听请求状态，获取响应数据：  
        ```javascript
        xhr.onreadystatechange = function () {
          // 当请求完成且响应成功（状态码 200）时处理数据
          if (xhr.readyState === 4 && xhr.status === 200) {
            var textData = xhr.responseText; // 接收文本格式数据
            var xmlData = xhr.responseXML;   // 接收 XML 格式数据（已极少用）
            console.log(textData);
          }
        }
        ```
   - **解决 IE 缓存问题**：  
     IE 浏览器会缓存 AJAX 请求结果，后续相同 URL 的请求会直接加载缓存，不发送新请求。  
     解决方案：在 URL 后添加时间戳，确保每次请求 URL 唯一，如：  
     ```javascript
     xhr.open("get", "/testAJAX?t=" + Date.now()); // Date.now() 生成当前时间戳
     ```
   - **AJAX 请求状态（xhr.readyState）**：

   | 状态值 | 描述                                                |
   | ------ | --------------------------------------------------- |
   | 0      | XMLHttpRequest 实例已创建，但 `open()` 未调用       |
   | 1      | `open()` 已调用，但 `send()` 未调用（可设置请求头） |
   | 2      | `send()` 已执行，已接收响应头和状态码               |
   | 3      | 正在接收服务器返回的响应体数据（部分数据可用）      |
   | 4      | 响应已完全接收（或请求失败）                        |

   ---


### 二、jQuery 中的 AJAX
jQuery 封装了原生 AJAX 语法，简化请求代码，核心提供 `get` 和 `post` 两种请求方式。

1. **get 请求**：
   - 语法：`$.get(url, [data], [callback], [type])`
   - 参数说明：

| 参数     | 类型          | 描述                                                         |
| -------- | ------------- | ------------------------------------------------------------ |
| url      | String        | 必选，请求的 URL 地址                                        |
| data     | Object/String | 可选，请求携带的参数（如 `{name: 'lisi', age: 22}` 或 `name=lisi&age=22`） |
| callback | Function      | 可选，请求成功后的回调函数（参数为响应数据）                 |
| type     | String        | 可选，指定响应数据格式（如 json、text、html，默认自动识别）  |

   - 示例：  
     ```javascript
     $.get("/getUser", {id: 123}, function (data) {
       console.log("用户信息：", data);
     }, "json");
     ```

2. **post 请求**：
   - 语法：`$.post(url, [data], [callback], [type])`
   - 参数说明：与 `$.get()` 完全一致（仅请求方式不同）。
   - 示例：  
     ```javascript
     $.post("/addUser", {name: "wangwu", age: 25}, function (res) {
       console.log("添加结果：", res);
     }, "text");
     ```

---

### 三、跨域
1. **同源策略**：
   - 定义：由 Netscape 提出的浏览器安全策略，限制不同源的页面访问彼此资源。
   - 同源判定：协议、域名、端口号必须完全相同，否则即为跨域。
   - 示例（以 `http://localhost:8080` 为基准）：
     - `https://localhost:8080`：协议不同（跨域）。
     - `http://www.baidu.com:8080`：域名不同（跨域）。
     - `http://localhost:8081`：端口不同（跨域）。
     - `http://localhost:8080/index.html`：同源（协议、域名、端口相同）。

2. **跨域解决方案**：

#### 2.1 JSONP
   - 定义：JSON with Padding，非官方跨域方案，仅支持 GET 请求。
   - 原理：利用 `<script>` 标签天生支持跨域的特性（如引入外部 CDN 脚本），通过动态创建 `<script>` 标签发送请求。
   - **使用步骤**：
     1. **客户端**：动态创建 `<script>` 标签，指定请求 URL 和回调函数；  
        ```javascript
        // 1. 创建 script 标签
        var script = document.createElement("script");
        // 2. 设置 src（包含回调函数名 callback=abc）
        script.src = "http://localhost:3000/testAJAX?callback=abc";
        // 3. 定义回调函数（接收服务器返回的数据）
        function abc(data) {
          alert("服务器返回：" + data.name); // 输出 "孙悟空"
        }
        // 4. 将 script 加入页面（触发请求）
        document.body.appendChild(script);
        ```
     2. **服务器端**：接收回调函数名，返回“回调函数(数据)”格式的响应（以 Express 框架为例）；  
        ```javascript
        router.get("/testAJAX", function (req, res) {
          // 1. 获取客户端传递的回调函数名
          var callbackName = req.query.callback;
          // 2. 构造要返回的数据
          var data = {name: "孙悟空", age: 18};
          // 3. 返回 "abc({...})" 格式的响应（客户端会执行 abc 函数）
          res.send(callbackName + "(" + JSON.stringify(data) + ")");
        });
        ```
   - **jQuery 中的 JSONP**：无需手动创建 `<script>` 标签，只需将 `callback` 参数设为 `?`（jQuery 自动生成回调函数）；  
     ```javascript
     <script src="./jquery-1.12.3.js"></script>
     <script>
       $("#btn").click(function () {
         // 请求豆瓣电影接口（跨域）
         $.getJSON("http://api.douban.com/v2/movie/in_theaters?callback=?", function (data) {
           // 遍历数据，渲染电影列表
           var subjects = data.subjects;
           subjects.forEach(function (movie) {
             $("#list").append(`<li>${movie.title}<br><img src="${movie.images.large}"></li>`);
           });
         });
       });
     </script>
     ```

#### 2.2 CORS
   - 定义：Cross-Origin Resource Sharing（跨域资源共享），官方跨域方案，支持 GET/POST 等所有请求方式；无需客户端额外操作，仅需服务器配置。
   - 原理：服务器通过设置响应头 `Access-Control-Allow-Origin`，告知浏览器“允许该源跨域访问”，浏览器收到后放行响应。
   - **使用步骤**：仅需在服务器端设置响应头（以 Express 框架为例）；  
     ```javascript
     router.get("/testAJAX", function (req, res) {
       // 配置跨域：允许指定源访问（如 http://127.0.0.1:3000）
       // res.set("Access-Control-Allow-Origin", "http://127.0.0.1:3000");
       // 配置跨域：允许所有源访问（开发环境可用，生产环境不推荐）
       res.set("Access-Control-Allow-Origin", "*");
       // 返回响应数据
       res.send("跨域请求成功！");
     });
     ```
   - 参考文档：MDN - CORS


